# app/api/auth/routes.py
from flask import Blueprint, current_app, request, jsonify, redirect, session, url_for
from urllib.parse import urlencode
import os, secrets, time, requests

from google.oauth2 import id_token
from google.auth.transport import requests as google_requests

from app import db
from app.models.user import User  # ajusta si tu path es distinto

auth_bp = Blueprint("auth", __name__)

GOOGLE_AUTH_URL = "https://accounts.google.com/o/oauth2/v2/auth"
GOOGLE_TOKEN_URL = "https://oauth2.googleapis.com/token"

# --- Helpers ---
def _build_google_auth_url():
    state = secrets.token_urlsafe(24)
    nonce = secrets.token_urlsafe(24)

    session["oauth_state"] = state
    session["oauth_nonce"] = nonce
    session["oauth_state_ts"] = int(time.time())

    params = {
        "client_id": current_app.config["GOOGLE_CLIENT_ID"],
        "redirect_uri": current_app.config["OAUTH_REDIRECT_URI"],
        "response_type": "code",
        "scope": "openid email profile",
        "access_type": "offline",
        "include_granted_scopes": "true",
        "state": state,
        "nonce": nonce,
        # Sugerencia para cuentas del dominio (solo “advice”, siempre valida server-side):
        "hd": current_app.config.get("ALLOWED_EMAIL_DOMAIN", ""),
        "prompt": "consent",  # opcional; para forzar selección/cambio de cuenta
    }
    return f"{GOOGLE_AUTH_URL}?{urlencode(params)}"

def _exchange_code_for_tokens(code: str):
    data = {
        "code": code,
        "client_id": current_app.config["GOOGLE_CLIENT_ID"],
        "client_secret": current_app.config["GOOGLE_CLIENT_SECRET"],
        "redirect_uri": current_app.config["OAUTH_REDIRECT_URI"],
        "grant_type": "authorization_code",
    }
    r = requests.post(GOOGLE_TOKEN_URL, data=data, timeout=15)
    r.raise_for_status()
    return r.json()  # { access_token, id_token, refresh_token?, expires_in, ... }

def _verify_id_token(idt: str):
    # Verifica firma y audiencia del token
    req = google_requests.Request()
    claims = id_token.verify_oauth2_token(
        idt, req, audience=current_app.config["GOOGLE_CLIENT_ID"]
    )
    return claims  # dict con 'email', 'email_verified', 'name', 'picture', 'hd', 'sub', etc.

def _require_domain(email: str):
    domain = email.split("@")[-1].lower()
    allowed = current_app.config.get("ALLOWED_EMAIL_DOMAIN", "").lower()
    return allowed and (domain == allowed)

# --- Rutas ---
@auth_bp.get("/google/login")
def google_login():
    # Limpia estados antiguos (opcional)
    session.pop("user_id", None)
    return redirect(_build_google_auth_url())

@auth_bp.get("/google/callback")
def google_callback():
    # Validación de errores
    error = request.args.get("error")
    if error:
        return redirect(f"http://localhost:5173/login?error={error}")  # ajusta tu front

    state = request.args.get("state")
    code = request.args.get("code")

    # Protege contra CSRF con state (y expira en 5 min)
    saved_state = session.get("oauth_state")
    saved_ts = session.get("oauth_state_ts", 0)
    if not state or state != saved_state or int(time.time()) - int(saved_ts) > 300:
        return redirect("http://localhost:5173/login?error=invalid_state")

    try:
        token_payload = _exchange_code_for_tokens(code)
        idt = token_payload.get("id_token")
        claims = _verify_id_token(idt)
    except Exception as e:
        return redirect(f"http://localhost:5173/login?error=token_error")

    # Valida NONCE (recomendada)
    nonce = session.get("oauth_nonce")
    if claims.get("nonce") != nonce:
        return redirect("http://localhost:5173/login?error=invalid_nonce")

    # Valida email y dominio
    email = claims.get("email")
    email_verified = claims.get("email_verified")
    if not email or not email_verified:
        return redirect("http://localhost:5173/login?error=email_not_verified")

    if not _require_domain(email):
        return redirect("http://localhost:5173/login?error=forbidden_domain")

    # Busca/crea usuario
    user = User.query.filter_by(email=email).first()
    if not user:
        user = User(
            email=email,
            name=claims.get("name"),
            picture=claims.get("picture"),
            provider="google",
            provider_sub=claims.get("sub"),
        )
        db.session.add(user)
        db.session.commit()

    # Inicia sesión (server-side session)
    session["user_id"] = user.id

    # Limpia estado oauth
    for k in ("oauth_state", "oauth_nonce", "oauth_state_ts"):
        session.pop(k, None)

    # Redirige al front ya autenticado
    return redirect("http://localhost:5173/")  # o a /dashboard

@auth_bp.get("/me")
def me():
    uid = session.get("user_id")
    if not uid:
        return jsonify({"authenticated": False}), 401
    user = User.query.get(uid)
    return jsonify({
        "authenticated": True,
        "id": user.id,
        "email": user.email,
        "name": getattr(user, "name", None),
        "picture": getattr(user, "picture", None),
    })

@auth_bp.post("/logout")
def logout():
    session.clear()
    return jsonify({"ok": True})
